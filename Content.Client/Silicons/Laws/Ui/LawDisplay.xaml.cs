using Content.Client.Chat.Managers;
using Content.Client.Message;
using Content.Shared.Chat;
using Content.Shared.Radio;
using Content.Shared.Silicons.Laws;
using Content.Shared.Speech;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;

namespace Content.Client.Silicons.Laws.Ui;

[GenerateTypedNameReferences]
public sealed partial class LawDisplay : Control
{
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
    [Dependency] private readonly IChatManager _chatManager = default!;
    [Dependency] private readonly EntityManager _entityManager = default!;

    public LawDisplay(EntityUid uid, SiliconLaw law, HashSet<string>? radioChannels, string? selectedChannel)
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        var identifier = law.LawIdentifierOverride ?? $"{law.Order}";
        var lawIdentifier = Loc.GetString("laws-ui-law-header", ("id", identifier));
        var lawDescription = Loc.GetString(law.LawString);
        var lawIdentifierPlaintext = FormattedMessage.RemoveMarkupPermissive(lawIdentifier);
        var lawDescriptionPlaintext = FormattedMessage.RemoveMarkupPermissive(lawDescription);

        LawNumberLabel.SetMarkup(lawIdentifier);
        LawLabel.SetMessage(lawDescription);

        // If you can't talk, you can't state your laws...
        if (!_entityManager.TryGetComponent<SpeechComponent>(uid, out var speech) || speech.SpeechSounds is null)
            return;

        // New unified button to work with drop down list
        var stateLawButton = new Button
        {
            Text = Loc.GetString("laws-ui-state-law"),
            Modulate = Color.LightBlue,
            StyleClasses = { "chatSelectorOptionButton" },
            MinHeight = 35,
            MinWidth = 100,
        };

        stateLawButton.OnPressed += _ =>
        {
            // Local and Binary channels are added to the list outside of the Radio component, so we handle them uniquely
            if (selectedChannel == SharedChatSystem.LocalChannel)
                _chatManager.SendMessage($"{lawIdentifierPlaintext}: {lawDescriptionPlaintext}", ChatSelectChannel.Local);
            else if (selectedChannel == SharedChatSystem.BinaryChannel)
                _chatManager.SendMessage($"{SharedChatSystem.RadioChannelPrefix}b {lawIdentifierPlaintext}: {lawDescriptionPlaintext}", ChatSelectChannel.Radio);
            else
            {
                if (radioChannels == null)
                    return;

                if (selectedChannel != null && radioChannels.Contains(selectedChannel))
                {
                    _prototypeManager.TryIndex<RadioChannelPrototype>(selectedChannel, out var radioChannelProto);
                    if (radioChannelProto == null)
                        return;
                    switch (radioChannelProto.ID)
                    {
                        case SharedChatSystem.CommonChannel:
                            _chatManager.SendMessage($"{SharedChatSystem.RadioCommonPrefix} {lawIdentifierPlaintext}: {lawDescriptionPlaintext}", ChatSelectChannel.Radio); break;
                        default:
                            _chatManager.SendMessage($"{SharedChatSystem.RadioChannelPrefix}{radioChannelProto.KeyCode} {lawIdentifierPlaintext}: {lawDescriptionPlaintext}", ChatSelectChannel.Radio); break;
                    }
                }
            }
        };
        // Add our unified button to the UI
        LawAnnouncementButtons.AddChild(stateLawButton);
    }
}
